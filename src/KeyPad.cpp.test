/**
 * Pins:
 * D2 - D9 (Arduino) -> 1 - 8 (4x4 Keypad)
 * PORT_D D7,D6,D5,D4,D3,D2,D1,D0
 * PORT_B X,X,D13,D12,D11,D10,D9,D8
 * PORT_C X,X,A5,A4,A3,A2,A1,A0
 * 
 * 2 - 5 Output High 6-9 Input 
 * 
 */

#include <Arduino.h>

const int rows[4] = {2, 3, 4, 5};
const int cols[4] = {6, 7, 8, 9};

int tasten[4][4] = {
    {1, 2, 3, 10},
    {4, 5, 6, 11},
    {7, 8, 9, 12},
    {13, 0, 14, 15}};

boolean released = true;

void initKeys()
{
  // D2 - D5 auf Input und Pullup-Widerstand
  DDRD &= 0b11000011;
  PORTD |= 0b00111100;

  // D6 - D9 auf Output und Low
  DDRD |= 0b11000000;
  PORTD &= 0b00111111;
  DDRB |= 0b00000011;
  PORTB &= 0b11111100;
}

void getKey()
{
  // Pins lesen
  delayMicroseconds(100);
  uint16_t input = ~PINB;
  input <<= 8;
  input |= ~PIND;

  // (oder) D2 bis D5 auf Low
  if (input & 0b111100)
  {

    // Lesen
    uint16_t input = ~PINB;
    input <<= 8;
    input |= ~PIND;

    uint16_t input_mask = 0;
    uint16_t DDRB_DDRD = 0;

    // Data direction to Output
    DDRB |= 0b00000011;
    DDRD |= 0b11000000;
    DDRB_DDRD = DDRB;
    DDRB_DDRD <<= 8;
    DDRB_DDRD |= DDRD;

    for (int i = 6; i <= 9; i++)
    {

      // Mask um bestimmten Pin von Output auf Input zu invertieren
      input_mask = 0x1 << i;

      // Einzelnes Bit invertieren
      DDRB_DDRD ^= input_mask;
      DDRD = DDRB_DDRD & 0xFF;
      DDRB = (DDRB_DDRD >> 8) & 0xF;
      delayMicroseconds(3);

      // Input
      input = ~PINB;
      input <<= 8;
      input |= ~PIND;

      for (int j = 0; j < 4; j++)
      {
        if (input & (0b100 << j))
        {
          Serial.print("i: ");
          Serial.println(i);

          Serial.print("Reihe: ");
          Serial.println(j);

          //Serial.print("Input mask: ");
          //Serial.println(input_mask, BIN);

          //Serial.print("DDRB_DDRD: ");
          //Serial.println(DDRB_DDRD, BIN);

          //Serial.print("DDRB: ");
          //Serial.println(DDRB, BIN);

          //Serial.print("DDRD: ");
          //Serial.println(DDRD, BIN);
        }
      }

      // RÃ¼cksetzen
      DDRB_DDRD |= input_mask;
      DDRD = DDRB_DDRD & 0xFF;
      DDRB = (DDRB_DDRD >> 8) & 0xF;
    }
  }
}

void setup()
{
  Serial.begin(9600);
}

void loop()
{
  delay(500);
  initKeys();
  getKey();
}

/** Alternativvariante mit digitalWrite/digitalRead

int tasten[4][4] = {
    {1, 2, 3, 10},
    {4, 5, 6, 11},
    {7, 8, 9, 12},
    {13, 0, 14, 15}};

boolean released = true;

int getKey()
{
  byte column = 0;
  byte row = 0;

  // Look for connections - column wise
  for (int i = 2; i <= 5; i++)
  {
    pinMode(i, OUTPUT);
    digitalWrite(i, 1);
  }

  for (int i = 6; i <= 9; i++)
  {
    pinMode(i, INPUT);
    if (digitalRead(i) == 1)
    {
      column = i - 5;
    }
    pinMode(i, OUTPUT);
  }

  //Check if any connection was present
  if (column == 0)
  {
    released = true;
    return -1;
  }

  // Look for connections - row wise
  for (int i = 2; i <= 5; i++)
  {
    digitalWrite(i, 0);
  }

  for (int i = 6; i <= 9; i++)
  {
    pinMode(i, OUTPUT);
    digitalWrite(i, 1);
  }

  for (int i = 2; i <= 5; i++)
  {
    pinMode(i, INPUT);
    if (digitalRead(i) == 1)
    {
      row = i - 1;
      break;
    }
    pinMode(i, OUTPUT);
  }

  for (int i = 6; i <= 9; i++)
  {
    digitalWrite(i, 0);
  }

  // return array matrix mapped to keypad
  if (released)
  {
    released = false;
    return tasten[row - 1][column - 1];
  }
  else
  {
    return -1;
  }
}
*/